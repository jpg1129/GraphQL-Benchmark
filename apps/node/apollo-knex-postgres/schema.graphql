schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# columns and relationships of "album"
type album {
  albumid: bigint!

  # An object relationship
  artist: artist
  artistid: bigint
  title: String

  # An array relationship
  tracks(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): [track!]!

  # An aggregated array relationship
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): track_aggregate!
}

# aggregated selection of "album"
type album_aggregate {
  aggregate: album_aggregate_fields
  nodes: [album!]!
}

# aggregate fields of "album"
type album_aggregate_fields {
  avg: album_avg_fields
  count(columns: [album_select_column!], distinct: Boolean): Int
  max: album_max_fields
  min: album_min_fields
  stddev: album_stddev_fields
  stddev_pop: album_stddev_pop_fields
  stddev_samp: album_stddev_samp_fields
  sum: album_sum_fields
  var_pop: album_var_pop_fields
  var_samp: album_var_samp_fields
  variance: album_variance_fields
}

# order by aggregate values of table "album"
input album_aggregate_order_by {
  avg: album_avg_order_by
  count: order_by
  max: album_max_order_by
  min: album_min_order_by
  stddev: album_stddev_order_by
  stddev_pop: album_stddev_pop_order_by
  stddev_samp: album_stddev_samp_order_by
  sum: album_sum_order_by
  var_pop: album_var_pop_order_by
  var_samp: album_var_samp_order_by
  variance: album_variance_order_by
}

# input type for inserting array relation for remote table "album"
input album_arr_rel_insert_input {
  data: [album_insert_input!]!
  on_conflict: album_on_conflict
}

# aggregate avg on columns
type album_avg_fields {
  albumid: Float
  artistid: Float
}

# order by avg() on columns of table "album"
input album_avg_order_by {
  albumid: order_by
  artistid: order_by
}

# Boolean expression to filter rows from the table "album". All fields are combined with a logical 'AND'.
input album_bool_exp {
  _and: [album_bool_exp]
  _not: album_bool_exp
  _or: [album_bool_exp]
  albumid: bigint_comparison_exp
  artist: artist_bool_exp
  artistid: bigint_comparison_exp
  title: String_comparison_exp
  tracks: track_bool_exp
}

# unique or primary key constraints on table "album"
enum album_constraint {
  # unique or primary key constraint
  idx_16684_album_pkey

  # unique or primary key constraint
  idx_16684_ipk_album
}

# input type for incrementing integer column in table "album"
input album_inc_input {
  albumid: bigint
  artistid: bigint
}

# input type for inserting data into table "album"
input album_insert_input {
  albumid: bigint
  artist: artist_obj_rel_insert_input
  artistid: bigint
  title: String
  tracks: track_arr_rel_insert_input
}

# aggregate max on columns
type album_max_fields {
  albumid: bigint
  artistid: bigint
  title: String
}

# order by max() on columns of table "album"
input album_max_order_by {
  albumid: order_by
  artistid: order_by
  title: order_by
}

# aggregate min on columns
type album_min_fields {
  albumid: bigint
  artistid: bigint
  title: String
}

# order by min() on columns of table "album"
input album_min_order_by {
  albumid: order_by
  artistid: order_by
  title: order_by
}

# response of any mutation on the table "album"
type album_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [album!]!
}

# input type for inserting object relation for remote table "album"
input album_obj_rel_insert_input {
  data: album_insert_input!
  on_conflict: album_on_conflict
}

# on conflict condition type for table "album"
input album_on_conflict {
  constraint: album_constraint!
  update_columns: [album_update_column!]!
  where: album_bool_exp
}

# ordering options when selecting data from "album"
input album_order_by {
  albumid: order_by
  artist: artist_order_by
  artistid: order_by
  title: order_by
  tracks_aggregate: track_aggregate_order_by
}

# primary key columns input for table: "album"
input album_pk_columns_input {
  albumid: bigint!
}

# select columns of table "album"
enum album_select_column {
  # column name
  albumid

  # column name
  artistid

  # column name
  title
}

# input type for updating data in table "album"
input album_set_input {
  albumid: bigint
  artistid: bigint
  title: String
}

# aggregate stddev on columns
type album_stddev_fields {
  albumid: Float
  artistid: Float
}

# order by stddev() on columns of table "album"
input album_stddev_order_by {
  albumid: order_by
  artistid: order_by
}

# aggregate stddev_pop on columns
type album_stddev_pop_fields {
  albumid: Float
  artistid: Float
}

# order by stddev_pop() on columns of table "album"
input album_stddev_pop_order_by {
  albumid: order_by
  artistid: order_by
}

# aggregate stddev_samp on columns
type album_stddev_samp_fields {
  albumid: Float
  artistid: Float
}

# order by stddev_samp() on columns of table "album"
input album_stddev_samp_order_by {
  albumid: order_by
  artistid: order_by
}

# aggregate sum on columns
type album_sum_fields {
  albumid: bigint
  artistid: bigint
}

# order by sum() on columns of table "album"
input album_sum_order_by {
  albumid: order_by
  artistid: order_by
}

# update columns of table "album"
enum album_update_column {
  # column name
  albumid

  # column name
  artistid

  # column name
  title
}

# aggregate var_pop on columns
type album_var_pop_fields {
  albumid: Float
  artistid: Float
}

# order by var_pop() on columns of table "album"
input album_var_pop_order_by {
  albumid: order_by
  artistid: order_by
}

# aggregate var_samp on columns
type album_var_samp_fields {
  albumid: Float
  artistid: Float
}

# order by var_samp() on columns of table "album"
input album_var_samp_order_by {
  albumid: order_by
  artistid: order_by
}

# aggregate variance on columns
type album_variance_fields {
  albumid: Float
  artistid: Float
}

# order by variance() on columns of table "album"
input album_variance_order_by {
  albumid: order_by
  artistid: order_by
}

# columns and relationships of "artist"
type artist {
  # An array relationship
  albums(
    # distinct select on columns
    distinct_on: [album_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [album_order_by!]

    # filter the rows returned
    where: album_bool_exp
  ): [album!]!

  # An aggregated array relationship
  albums_aggregate(
    # distinct select on columns
    distinct_on: [album_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [album_order_by!]

    # filter the rows returned
    where: album_bool_exp
  ): album_aggregate!
  artistid: bigint!
  name: String
}

# aggregated selection of "artist"
type artist_aggregate {
  aggregate: artist_aggregate_fields
  nodes: [artist!]!
}

# aggregate fields of "artist"
type artist_aggregate_fields {
  avg: artist_avg_fields
  count(columns: [artist_select_column!], distinct: Boolean): Int
  max: artist_max_fields
  min: artist_min_fields
  stddev: artist_stddev_fields
  stddev_pop: artist_stddev_pop_fields
  stddev_samp: artist_stddev_samp_fields
  sum: artist_sum_fields
  var_pop: artist_var_pop_fields
  var_samp: artist_var_samp_fields
  variance: artist_variance_fields
}

# order by aggregate values of table "artist"
input artist_aggregate_order_by {
  avg: artist_avg_order_by
  count: order_by
  max: artist_max_order_by
  min: artist_min_order_by
  stddev: artist_stddev_order_by
  stddev_pop: artist_stddev_pop_order_by
  stddev_samp: artist_stddev_samp_order_by
  sum: artist_sum_order_by
  var_pop: artist_var_pop_order_by
  var_samp: artist_var_samp_order_by
  variance: artist_variance_order_by
}

# input type for inserting array relation for remote table "artist"
input artist_arr_rel_insert_input {
  data: [artist_insert_input!]!
  on_conflict: artist_on_conflict
}

# aggregate avg on columns
type artist_avg_fields {
  artistid: Float
}

# order by avg() on columns of table "artist"
input artist_avg_order_by {
  artistid: order_by
}

# Boolean expression to filter rows from the table "artist". All fields are combined with a logical 'AND'.
input artist_bool_exp {
  _and: [artist_bool_exp]
  _not: artist_bool_exp
  _or: [artist_bool_exp]
  albums: album_bool_exp
  artistid: bigint_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "artist"
enum artist_constraint {
  # unique or primary key constraint
  idx_16693_artist_pkey

  # unique or primary key constraint
  idx_16693_ipk_artist
}

# input type for incrementing integer column in table "artist"
input artist_inc_input {
  artistid: bigint
}

# input type for inserting data into table "artist"
input artist_insert_input {
  albums: album_arr_rel_insert_input
  artistid: bigint
  name: String
}

# aggregate max on columns
type artist_max_fields {
  artistid: bigint
  name: String
}

# order by max() on columns of table "artist"
input artist_max_order_by {
  artistid: order_by
  name: order_by
}

# aggregate min on columns
type artist_min_fields {
  artistid: bigint
  name: String
}

# order by min() on columns of table "artist"
input artist_min_order_by {
  artistid: order_by
  name: order_by
}

# response of any mutation on the table "artist"
type artist_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [artist!]!
}

# input type for inserting object relation for remote table "artist"
input artist_obj_rel_insert_input {
  data: artist_insert_input!
  on_conflict: artist_on_conflict
}

# on conflict condition type for table "artist"
input artist_on_conflict {
  constraint: artist_constraint!
  update_columns: [artist_update_column!]!
  where: artist_bool_exp
}

# ordering options when selecting data from "artist"
input artist_order_by {
  albums_aggregate: album_aggregate_order_by
  artistid: order_by
  name: order_by
}

# primary key columns input for table: "artist"
input artist_pk_columns_input {
  artistid: bigint!
}

# select columns of table "artist"
enum artist_select_column {
  # column name
  artistid

  # column name
  name
}

# input type for updating data in table "artist"
input artist_set_input {
  artistid: bigint
  name: String
}

# aggregate stddev on columns
type artist_stddev_fields {
  artistid: Float
}

# order by stddev() on columns of table "artist"
input artist_stddev_order_by {
  artistid: order_by
}

# aggregate stddev_pop on columns
type artist_stddev_pop_fields {
  artistid: Float
}

# order by stddev_pop() on columns of table "artist"
input artist_stddev_pop_order_by {
  artistid: order_by
}

# aggregate stddev_samp on columns
type artist_stddev_samp_fields {
  artistid: Float
}

# order by stddev_samp() on columns of table "artist"
input artist_stddev_samp_order_by {
  artistid: order_by
}

# aggregate sum on columns
type artist_sum_fields {
  artistid: bigint
}

# order by sum() on columns of table "artist"
input artist_sum_order_by {
  artistid: order_by
}

# update columns of table "artist"
enum artist_update_column {
  # column name
  artistid

  # column name
  name
}

# aggregate var_pop on columns
type artist_var_pop_fields {
  artistid: Float
}

# order by var_pop() on columns of table "artist"
input artist_var_pop_order_by {
  artistid: order_by
}

# aggregate var_samp on columns
type artist_var_samp_fields {
  artistid: Float
}

# order by var_samp() on columns of table "artist"
input artist_var_samp_order_by {
  artistid: order_by
}

# aggregate variance on columns
type artist_variance_fields {
  artistid: Float
}

# order by variance() on columns of table "artist"
input artist_variance_order_by {
  artistid: order_by
}

scalar bigint

# expression to compare columns of type bigint. All fields are combined with logical 'AND'.
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

# columns and relationships of "customer"
type customer {
  address: String
  city: String
  company: String
  country: String
  customerid: bigint!
  email: String

  # An object relationship
  employee: employee
  fax: String
  firstname: String

  # An array relationship
  invoices(
    # distinct select on columns
    distinct_on: [invoice_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_order_by!]

    # filter the rows returned
    where: invoice_bool_exp
  ): [invoice!]!

  # An aggregated array relationship
  invoices_aggregate(
    # distinct select on columns
    distinct_on: [invoice_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_order_by!]

    # filter the rows returned
    where: invoice_bool_exp
  ): invoice_aggregate!
  lastname: String
  phone: String
  postalcode: String
  state: String
  supportrepid: bigint
}

# aggregated selection of "customer"
type customer_aggregate {
  aggregate: customer_aggregate_fields
  nodes: [customer!]!
}

# aggregate fields of "customer"
type customer_aggregate_fields {
  avg: customer_avg_fields
  count(columns: [customer_select_column!], distinct: Boolean): Int
  max: customer_max_fields
  min: customer_min_fields
  stddev: customer_stddev_fields
  stddev_pop: customer_stddev_pop_fields
  stddev_samp: customer_stddev_samp_fields
  sum: customer_sum_fields
  var_pop: customer_var_pop_fields
  var_samp: customer_var_samp_fields
  variance: customer_variance_fields
}

# order by aggregate values of table "customer"
input customer_aggregate_order_by {
  avg: customer_avg_order_by
  count: order_by
  max: customer_max_order_by
  min: customer_min_order_by
  stddev: customer_stddev_order_by
  stddev_pop: customer_stddev_pop_order_by
  stddev_samp: customer_stddev_samp_order_by
  sum: customer_sum_order_by
  var_pop: customer_var_pop_order_by
  var_samp: customer_var_samp_order_by
  variance: customer_variance_order_by
}

# input type for inserting array relation for remote table "customer"
input customer_arr_rel_insert_input {
  data: [customer_insert_input!]!
  on_conflict: customer_on_conflict
}

# aggregate avg on columns
type customer_avg_fields {
  customerid: Float
  supportrepid: Float
}

# order by avg() on columns of table "customer"
input customer_avg_order_by {
  customerid: order_by
  supportrepid: order_by
}

# Boolean expression to filter rows from the table "customer". All fields are combined with a logical 'AND'.
input customer_bool_exp {
  _and: [customer_bool_exp]
  _not: customer_bool_exp
  _or: [customer_bool_exp]
  address: String_comparison_exp
  city: String_comparison_exp
  company: String_comparison_exp
  country: String_comparison_exp
  customerid: bigint_comparison_exp
  email: String_comparison_exp
  employee: employee_bool_exp
  fax: String_comparison_exp
  firstname: String_comparison_exp
  invoices: invoice_bool_exp
  lastname: String_comparison_exp
  phone: String_comparison_exp
  postalcode: String_comparison_exp
  state: String_comparison_exp
  supportrepid: bigint_comparison_exp
}

# unique or primary key constraints on table "customer"
enum customer_constraint {
  # unique or primary key constraint
  idx_16702_customer_pkey

  # unique or primary key constraint
  idx_16702_ipk_customer
}

# input type for incrementing integer column in table "customer"
input customer_inc_input {
  customerid: bigint
  supportrepid: bigint
}

# input type for inserting data into table "customer"
input customer_insert_input {
  address: String
  city: String
  company: String
  country: String
  customerid: bigint
  email: String
  employee: employee_obj_rel_insert_input
  fax: String
  firstname: String
  invoices: invoice_arr_rel_insert_input
  lastname: String
  phone: String
  postalcode: String
  state: String
  supportrepid: bigint
}

# aggregate max on columns
type customer_max_fields {
  address: String
  city: String
  company: String
  country: String
  customerid: bigint
  email: String
  fax: String
  firstname: String
  lastname: String
  phone: String
  postalcode: String
  state: String
  supportrepid: bigint
}

# order by max() on columns of table "customer"
input customer_max_order_by {
  address: order_by
  city: order_by
  company: order_by
  country: order_by
  customerid: order_by
  email: order_by
  fax: order_by
  firstname: order_by
  lastname: order_by
  phone: order_by
  postalcode: order_by
  state: order_by
  supportrepid: order_by
}

# aggregate min on columns
type customer_min_fields {
  address: String
  city: String
  company: String
  country: String
  customerid: bigint
  email: String
  fax: String
  firstname: String
  lastname: String
  phone: String
  postalcode: String
  state: String
  supportrepid: bigint
}

# order by min() on columns of table "customer"
input customer_min_order_by {
  address: order_by
  city: order_by
  company: order_by
  country: order_by
  customerid: order_by
  email: order_by
  fax: order_by
  firstname: order_by
  lastname: order_by
  phone: order_by
  postalcode: order_by
  state: order_by
  supportrepid: order_by
}

# response of any mutation on the table "customer"
type customer_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [customer!]!
}

# input type for inserting object relation for remote table "customer"
input customer_obj_rel_insert_input {
  data: customer_insert_input!
  on_conflict: customer_on_conflict
}

# on conflict condition type for table "customer"
input customer_on_conflict {
  constraint: customer_constraint!
  update_columns: [customer_update_column!]!
  where: customer_bool_exp
}

# ordering options when selecting data from "customer"
input customer_order_by {
  address: order_by
  city: order_by
  company: order_by
  country: order_by
  customerid: order_by
  email: order_by
  employee: employee_order_by
  fax: order_by
  firstname: order_by
  invoices_aggregate: invoice_aggregate_order_by
  lastname: order_by
  phone: order_by
  postalcode: order_by
  state: order_by
  supportrepid: order_by
}

# primary key columns input for table: "customer"
input customer_pk_columns_input {
  customerid: bigint!
}

# select columns of table "customer"
enum customer_select_column {
  # column name
  address

  # column name
  city

  # column name
  company

  # column name
  country

  # column name
  customerid

  # column name
  email

  # column name
  fax

  # column name
  firstname

  # column name
  lastname

  # column name
  phone

  # column name
  postalcode

  # column name
  state

  # column name
  supportrepid
}

# input type for updating data in table "customer"
input customer_set_input {
  address: String
  city: String
  company: String
  country: String
  customerid: bigint
  email: String
  fax: String
  firstname: String
  lastname: String
  phone: String
  postalcode: String
  state: String
  supportrepid: bigint
}

# aggregate stddev on columns
type customer_stddev_fields {
  customerid: Float
  supportrepid: Float
}

# order by stddev() on columns of table "customer"
input customer_stddev_order_by {
  customerid: order_by
  supportrepid: order_by
}

# aggregate stddev_pop on columns
type customer_stddev_pop_fields {
  customerid: Float
  supportrepid: Float
}

# order by stddev_pop() on columns of table "customer"
input customer_stddev_pop_order_by {
  customerid: order_by
  supportrepid: order_by
}

# aggregate stddev_samp on columns
type customer_stddev_samp_fields {
  customerid: Float
  supportrepid: Float
}

# order by stddev_samp() on columns of table "customer"
input customer_stddev_samp_order_by {
  customerid: order_by
  supportrepid: order_by
}

# aggregate sum on columns
type customer_sum_fields {
  customerid: bigint
  supportrepid: bigint
}

# order by sum() on columns of table "customer"
input customer_sum_order_by {
  customerid: order_by
  supportrepid: order_by
}

# update columns of table "customer"
enum customer_update_column {
  # column name
  address

  # column name
  city

  # column name
  company

  # column name
  country

  # column name
  customerid

  # column name
  email

  # column name
  fax

  # column name
  firstname

  # column name
  lastname

  # column name
  phone

  # column name
  postalcode

  # column name
  state

  # column name
  supportrepid
}

# aggregate var_pop on columns
type customer_var_pop_fields {
  customerid: Float
  supportrepid: Float
}

# order by var_pop() on columns of table "customer"
input customer_var_pop_order_by {
  customerid: order_by
  supportrepid: order_by
}

# aggregate var_samp on columns
type customer_var_samp_fields {
  customerid: Float
  supportrepid: Float
}

# order by var_samp() on columns of table "customer"
input customer_var_samp_order_by {
  customerid: order_by
  supportrepid: order_by
}

# aggregate variance on columns
type customer_variance_fields {
  customerid: Float
  supportrepid: Float
}

# order by variance() on columns of table "customer"
input customer_variance_order_by {
  customerid: order_by
  supportrepid: order_by
}

# columns and relationships of "employee"
type employee {
  address: String
  birthdate: timestamptz
  city: String
  country: String

  # An array relationship
  customers(
    # distinct select on columns
    distinct_on: [customer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customer_order_by!]

    # filter the rows returned
    where: customer_bool_exp
  ): [customer!]!

  # An aggregated array relationship
  customers_aggregate(
    # distinct select on columns
    distinct_on: [customer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customer_order_by!]

    # filter the rows returned
    where: customer_bool_exp
  ): customer_aggregate!
  email: String

  # An object relationship
  employee: employee
  employeeid: bigint!

  # An array relationship
  employees(
    # distinct select on columns
    distinct_on: [employee_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employee_order_by!]

    # filter the rows returned
    where: employee_bool_exp
  ): [employee!]!

  # An aggregated array relationship
  employees_aggregate(
    # distinct select on columns
    distinct_on: [employee_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employee_order_by!]

    # filter the rows returned
    where: employee_bool_exp
  ): employee_aggregate!
  fax: String
  firstname: String
  hiredate: timestamptz
  lastname: String
  phone: String
  postalcode: String
  reportsto: bigint
  state: String
  title: String
}

# aggregated selection of "employee"
type employee_aggregate {
  aggregate: employee_aggregate_fields
  nodes: [employee!]!
}

# aggregate fields of "employee"
type employee_aggregate_fields {
  avg: employee_avg_fields
  count(columns: [employee_select_column!], distinct: Boolean): Int
  max: employee_max_fields
  min: employee_min_fields
  stddev: employee_stddev_fields
  stddev_pop: employee_stddev_pop_fields
  stddev_samp: employee_stddev_samp_fields
  sum: employee_sum_fields
  var_pop: employee_var_pop_fields
  var_samp: employee_var_samp_fields
  variance: employee_variance_fields
}

# order by aggregate values of table "employee"
input employee_aggregate_order_by {
  avg: employee_avg_order_by
  count: order_by
  max: employee_max_order_by
  min: employee_min_order_by
  stddev: employee_stddev_order_by
  stddev_pop: employee_stddev_pop_order_by
  stddev_samp: employee_stddev_samp_order_by
  sum: employee_sum_order_by
  var_pop: employee_var_pop_order_by
  var_samp: employee_var_samp_order_by
  variance: employee_variance_order_by
}

# input type for inserting array relation for remote table "employee"
input employee_arr_rel_insert_input {
  data: [employee_insert_input!]!
  on_conflict: employee_on_conflict
}

# aggregate avg on columns
type employee_avg_fields {
  employeeid: Float
  reportsto: Float
}

# order by avg() on columns of table "employee"
input employee_avg_order_by {
  employeeid: order_by
  reportsto: order_by
}

# Boolean expression to filter rows from the table "employee". All fields are combined with a logical 'AND'.
input employee_bool_exp {
  _and: [employee_bool_exp]
  _not: employee_bool_exp
  _or: [employee_bool_exp]
  address: String_comparison_exp
  birthdate: timestamptz_comparison_exp
  city: String_comparison_exp
  country: String_comparison_exp
  customers: customer_bool_exp
  email: String_comparison_exp
  employee: employee_bool_exp
  employeeid: bigint_comparison_exp
  employees: employee_bool_exp
  fax: String_comparison_exp
  firstname: String_comparison_exp
  hiredate: timestamptz_comparison_exp
  lastname: String_comparison_exp
  phone: String_comparison_exp
  postalcode: String_comparison_exp
  reportsto: bigint_comparison_exp
  state: String_comparison_exp
  title: String_comparison_exp
}

# unique or primary key constraints on table "employee"
enum employee_constraint {
  # unique or primary key constraint
  idx_16711_employee_pkey

  # unique or primary key constraint
  idx_16711_ipk_employee
}

# input type for incrementing integer column in table "employee"
input employee_inc_input {
  employeeid: bigint
  reportsto: bigint
}

# input type for inserting data into table "employee"
input employee_insert_input {
  address: String
  birthdate: timestamptz
  city: String
  country: String
  customers: customer_arr_rel_insert_input
  email: String
  employee: employee_obj_rel_insert_input
  employeeid: bigint
  employees: employee_arr_rel_insert_input
  fax: String
  firstname: String
  hiredate: timestamptz
  lastname: String
  phone: String
  postalcode: String
  reportsto: bigint
  state: String
  title: String
}

# aggregate max on columns
type employee_max_fields {
  address: String
  birthdate: timestamptz
  city: String
  country: String
  email: String
  employeeid: bigint
  fax: String
  firstname: String
  hiredate: timestamptz
  lastname: String
  phone: String
  postalcode: String
  reportsto: bigint
  state: String
  title: String
}

# order by max() on columns of table "employee"
input employee_max_order_by {
  address: order_by
  birthdate: order_by
  city: order_by
  country: order_by
  email: order_by
  employeeid: order_by
  fax: order_by
  firstname: order_by
  hiredate: order_by
  lastname: order_by
  phone: order_by
  postalcode: order_by
  reportsto: order_by
  state: order_by
  title: order_by
}

# aggregate min on columns
type employee_min_fields {
  address: String
  birthdate: timestamptz
  city: String
  country: String
  email: String
  employeeid: bigint
  fax: String
  firstname: String
  hiredate: timestamptz
  lastname: String
  phone: String
  postalcode: String
  reportsto: bigint
  state: String
  title: String
}

# order by min() on columns of table "employee"
input employee_min_order_by {
  address: order_by
  birthdate: order_by
  city: order_by
  country: order_by
  email: order_by
  employeeid: order_by
  fax: order_by
  firstname: order_by
  hiredate: order_by
  lastname: order_by
  phone: order_by
  postalcode: order_by
  reportsto: order_by
  state: order_by
  title: order_by
}

# response of any mutation on the table "employee"
type employee_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [employee!]!
}

# input type for inserting object relation for remote table "employee"
input employee_obj_rel_insert_input {
  data: employee_insert_input!
  on_conflict: employee_on_conflict
}

# on conflict condition type for table "employee"
input employee_on_conflict {
  constraint: employee_constraint!
  update_columns: [employee_update_column!]!
  where: employee_bool_exp
}

# ordering options when selecting data from "employee"
input employee_order_by {
  address: order_by
  birthdate: order_by
  city: order_by
  country: order_by
  customers_aggregate: customer_aggregate_order_by
  email: order_by
  employee: employee_order_by
  employeeid: order_by
  employees_aggregate: employee_aggregate_order_by
  fax: order_by
  firstname: order_by
  hiredate: order_by
  lastname: order_by
  phone: order_by
  postalcode: order_by
  reportsto: order_by
  state: order_by
  title: order_by
}

# primary key columns input for table: "employee"
input employee_pk_columns_input {
  employeeid: bigint!
}

# select columns of table "employee"
enum employee_select_column {
  # column name
  address

  # column name
  birthdate

  # column name
  city

  # column name
  country

  # column name
  email

  # column name
  employeeid

  # column name
  fax

  # column name
  firstname

  # column name
  hiredate

  # column name
  lastname

  # column name
  phone

  # column name
  postalcode

  # column name
  reportsto

  # column name
  state

  # column name
  title
}

# input type for updating data in table "employee"
input employee_set_input {
  address: String
  birthdate: timestamptz
  city: String
  country: String
  email: String
  employeeid: bigint
  fax: String
  firstname: String
  hiredate: timestamptz
  lastname: String
  phone: String
  postalcode: String
  reportsto: bigint
  state: String
  title: String
}

# aggregate stddev on columns
type employee_stddev_fields {
  employeeid: Float
  reportsto: Float
}

# order by stddev() on columns of table "employee"
input employee_stddev_order_by {
  employeeid: order_by
  reportsto: order_by
}

# aggregate stddev_pop on columns
type employee_stddev_pop_fields {
  employeeid: Float
  reportsto: Float
}

# order by stddev_pop() on columns of table "employee"
input employee_stddev_pop_order_by {
  employeeid: order_by
  reportsto: order_by
}

# aggregate stddev_samp on columns
type employee_stddev_samp_fields {
  employeeid: Float
  reportsto: Float
}

# order by stddev_samp() on columns of table "employee"
input employee_stddev_samp_order_by {
  employeeid: order_by
  reportsto: order_by
}

# aggregate sum on columns
type employee_sum_fields {
  employeeid: bigint
  reportsto: bigint
}

# order by sum() on columns of table "employee"
input employee_sum_order_by {
  employeeid: order_by
  reportsto: order_by
}

# update columns of table "employee"
enum employee_update_column {
  # column name
  address

  # column name
  birthdate

  # column name
  city

  # column name
  country

  # column name
  email

  # column name
  employeeid

  # column name
  fax

  # column name
  firstname

  # column name
  hiredate

  # column name
  lastname

  # column name
  phone

  # column name
  postalcode

  # column name
  reportsto

  # column name
  state

  # column name
  title
}

# aggregate var_pop on columns
type employee_var_pop_fields {
  employeeid: Float
  reportsto: Float
}

# order by var_pop() on columns of table "employee"
input employee_var_pop_order_by {
  employeeid: order_by
  reportsto: order_by
}

# aggregate var_samp on columns
type employee_var_samp_fields {
  employeeid: Float
  reportsto: Float
}

# order by var_samp() on columns of table "employee"
input employee_var_samp_order_by {
  employeeid: order_by
  reportsto: order_by
}

# aggregate variance on columns
type employee_variance_fields {
  employeeid: Float
  reportsto: Float
}

# order by variance() on columns of table "employee"
input employee_variance_order_by {
  employeeid: order_by
  reportsto: order_by
}

# columns and relationships of "genre"
type genre {
  genreid: bigint!
  name: String

  # An array relationship
  tracks(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): [track!]!

  # An aggregated array relationship
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): track_aggregate!
}

# aggregated selection of "genre"
type genre_aggregate {
  aggregate: genre_aggregate_fields
  nodes: [genre!]!
}

# aggregate fields of "genre"
type genre_aggregate_fields {
  avg: genre_avg_fields
  count(columns: [genre_select_column!], distinct: Boolean): Int
  max: genre_max_fields
  min: genre_min_fields
  stddev: genre_stddev_fields
  stddev_pop: genre_stddev_pop_fields
  stddev_samp: genre_stddev_samp_fields
  sum: genre_sum_fields
  var_pop: genre_var_pop_fields
  var_samp: genre_var_samp_fields
  variance: genre_variance_fields
}

# order by aggregate values of table "genre"
input genre_aggregate_order_by {
  avg: genre_avg_order_by
  count: order_by
  max: genre_max_order_by
  min: genre_min_order_by
  stddev: genre_stddev_order_by
  stddev_pop: genre_stddev_pop_order_by
  stddev_samp: genre_stddev_samp_order_by
  sum: genre_sum_order_by
  var_pop: genre_var_pop_order_by
  var_samp: genre_var_samp_order_by
  variance: genre_variance_order_by
}

# input type for inserting array relation for remote table "genre"
input genre_arr_rel_insert_input {
  data: [genre_insert_input!]!
  on_conflict: genre_on_conflict
}

# aggregate avg on columns
type genre_avg_fields {
  genreid: Float
}

# order by avg() on columns of table "genre"
input genre_avg_order_by {
  genreid: order_by
}

# Boolean expression to filter rows from the table "genre". All fields are combined with a logical 'AND'.
input genre_bool_exp {
  _and: [genre_bool_exp]
  _not: genre_bool_exp
  _or: [genre_bool_exp]
  genreid: bigint_comparison_exp
  name: String_comparison_exp
  tracks: track_bool_exp
}

# unique or primary key constraints on table "genre"
enum genre_constraint {
  # unique or primary key constraint
  idx_16720_genre_pkey

  # unique or primary key constraint
  idx_16720_ipk_genre
}

# input type for incrementing integer column in table "genre"
input genre_inc_input {
  genreid: bigint
}

# input type for inserting data into table "genre"
input genre_insert_input {
  genreid: bigint
  name: String
  tracks: track_arr_rel_insert_input
}

# aggregate max on columns
type genre_max_fields {
  genreid: bigint
  name: String
}

# order by max() on columns of table "genre"
input genre_max_order_by {
  genreid: order_by
  name: order_by
}

# aggregate min on columns
type genre_min_fields {
  genreid: bigint
  name: String
}

# order by min() on columns of table "genre"
input genre_min_order_by {
  genreid: order_by
  name: order_by
}

# response of any mutation on the table "genre"
type genre_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [genre!]!
}

# input type for inserting object relation for remote table "genre"
input genre_obj_rel_insert_input {
  data: genre_insert_input!
  on_conflict: genre_on_conflict
}

# on conflict condition type for table "genre"
input genre_on_conflict {
  constraint: genre_constraint!
  update_columns: [genre_update_column!]!
  where: genre_bool_exp
}

# ordering options when selecting data from "genre"
input genre_order_by {
  genreid: order_by
  name: order_by
  tracks_aggregate: track_aggregate_order_by
}

# primary key columns input for table: "genre"
input genre_pk_columns_input {
  genreid: bigint!
}

# select columns of table "genre"
enum genre_select_column {
  # column name
  genreid

  # column name
  name
}

# input type for updating data in table "genre"
input genre_set_input {
  genreid: bigint
  name: String
}

# aggregate stddev on columns
type genre_stddev_fields {
  genreid: Float
}

# order by stddev() on columns of table "genre"
input genre_stddev_order_by {
  genreid: order_by
}

# aggregate stddev_pop on columns
type genre_stddev_pop_fields {
  genreid: Float
}

# order by stddev_pop() on columns of table "genre"
input genre_stddev_pop_order_by {
  genreid: order_by
}

# aggregate stddev_samp on columns
type genre_stddev_samp_fields {
  genreid: Float
}

# order by stddev_samp() on columns of table "genre"
input genre_stddev_samp_order_by {
  genreid: order_by
}

# aggregate sum on columns
type genre_sum_fields {
  genreid: bigint
}

# order by sum() on columns of table "genre"
input genre_sum_order_by {
  genreid: order_by
}

# update columns of table "genre"
enum genre_update_column {
  # column name
  genreid

  # column name
  name
}

# aggregate var_pop on columns
type genre_var_pop_fields {
  genreid: Float
}

# order by var_pop() on columns of table "genre"
input genre_var_pop_order_by {
  genreid: order_by
}

# aggregate var_samp on columns
type genre_var_samp_fields {
  genreid: Float
}

# order by var_samp() on columns of table "genre"
input genre_var_samp_order_by {
  genreid: order_by
}

# aggregate variance on columns
type genre_variance_fields {
  genreid: Float
}

# order by variance() on columns of table "genre"
input genre_variance_order_by {
  genreid: order_by
}

# columns and relationships of "invoice"
type invoice {
  billingaddress: String
  billingcity: String
  billingcountry: String
  billingpostalcode: String
  billingstate: String

  # An object relationship
  customer: customer
  customerid: bigint
  invoicedate: timestamptz
  invoiceid: bigint!

  # An array relationship
  invoicelines(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): [invoiceline!]!

  # An aggregated array relationship
  invoicelines_aggregate(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): invoiceline_aggregate!
  total: numeric
}

# aggregated selection of "invoice"
type invoice_aggregate {
  aggregate: invoice_aggregate_fields
  nodes: [invoice!]!
}

# aggregate fields of "invoice"
type invoice_aggregate_fields {
  avg: invoice_avg_fields
  count(columns: [invoice_select_column!], distinct: Boolean): Int
  max: invoice_max_fields
  min: invoice_min_fields
  stddev: invoice_stddev_fields
  stddev_pop: invoice_stddev_pop_fields
  stddev_samp: invoice_stddev_samp_fields
  sum: invoice_sum_fields
  var_pop: invoice_var_pop_fields
  var_samp: invoice_var_samp_fields
  variance: invoice_variance_fields
}

# order by aggregate values of table "invoice"
input invoice_aggregate_order_by {
  avg: invoice_avg_order_by
  count: order_by
  max: invoice_max_order_by
  min: invoice_min_order_by
  stddev: invoice_stddev_order_by
  stddev_pop: invoice_stddev_pop_order_by
  stddev_samp: invoice_stddev_samp_order_by
  sum: invoice_sum_order_by
  var_pop: invoice_var_pop_order_by
  var_samp: invoice_var_samp_order_by
  variance: invoice_variance_order_by
}

# input type for inserting array relation for remote table "invoice"
input invoice_arr_rel_insert_input {
  data: [invoice_insert_input!]!
  on_conflict: invoice_on_conflict
}

# aggregate avg on columns
type invoice_avg_fields {
  customerid: Float
  invoiceid: Float
  total: Float
}

# order by avg() on columns of table "invoice"
input invoice_avg_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# Boolean expression to filter rows from the table "invoice". All fields are combined with a logical 'AND'.
input invoice_bool_exp {
  _and: [invoice_bool_exp]
  _not: invoice_bool_exp
  _or: [invoice_bool_exp]
  billingaddress: String_comparison_exp
  billingcity: String_comparison_exp
  billingcountry: String_comparison_exp
  billingpostalcode: String_comparison_exp
  billingstate: String_comparison_exp
  customer: customer_bool_exp
  customerid: bigint_comparison_exp
  invoicedate: timestamptz_comparison_exp
  invoiceid: bigint_comparison_exp
  invoicelines: invoiceline_bool_exp
  total: numeric_comparison_exp
}

# unique or primary key constraints on table "invoice"
enum invoice_constraint {
  # unique or primary key constraint
  idx_16729_invoice_pkey

  # unique or primary key constraint
  idx_16729_ipk_invoice
}

# input type for incrementing integer column in table "invoice"
input invoice_inc_input {
  customerid: bigint
  invoiceid: bigint
  total: numeric
}

# input type for inserting data into table "invoice"
input invoice_insert_input {
  billingaddress: String
  billingcity: String
  billingcountry: String
  billingpostalcode: String
  billingstate: String
  customer: customer_obj_rel_insert_input
  customerid: bigint
  invoicedate: timestamptz
  invoiceid: bigint
  invoicelines: invoiceline_arr_rel_insert_input
  total: numeric
}

# aggregate max on columns
type invoice_max_fields {
  billingaddress: String
  billingcity: String
  billingcountry: String
  billingpostalcode: String
  billingstate: String
  customerid: bigint
  invoicedate: timestamptz
  invoiceid: bigint
  total: numeric
}

# order by max() on columns of table "invoice"
input invoice_max_order_by {
  billingaddress: order_by
  billingcity: order_by
  billingcountry: order_by
  billingpostalcode: order_by
  billingstate: order_by
  customerid: order_by
  invoicedate: order_by
  invoiceid: order_by
  total: order_by
}

# aggregate min on columns
type invoice_min_fields {
  billingaddress: String
  billingcity: String
  billingcountry: String
  billingpostalcode: String
  billingstate: String
  customerid: bigint
  invoicedate: timestamptz
  invoiceid: bigint
  total: numeric
}

# order by min() on columns of table "invoice"
input invoice_min_order_by {
  billingaddress: order_by
  billingcity: order_by
  billingcountry: order_by
  billingpostalcode: order_by
  billingstate: order_by
  customerid: order_by
  invoicedate: order_by
  invoiceid: order_by
  total: order_by
}

# response of any mutation on the table "invoice"
type invoice_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [invoice!]!
}

# input type for inserting object relation for remote table "invoice"
input invoice_obj_rel_insert_input {
  data: invoice_insert_input!
  on_conflict: invoice_on_conflict
}

# on conflict condition type for table "invoice"
input invoice_on_conflict {
  constraint: invoice_constraint!
  update_columns: [invoice_update_column!]!
  where: invoice_bool_exp
}

# ordering options when selecting data from "invoice"
input invoice_order_by {
  billingaddress: order_by
  billingcity: order_by
  billingcountry: order_by
  billingpostalcode: order_by
  billingstate: order_by
  customer: customer_order_by
  customerid: order_by
  invoicedate: order_by
  invoiceid: order_by
  invoicelines_aggregate: invoiceline_aggregate_order_by
  total: order_by
}

# primary key columns input for table: "invoice"
input invoice_pk_columns_input {
  invoiceid: bigint!
}

# select columns of table "invoice"
enum invoice_select_column {
  # column name
  billingaddress

  # column name
  billingcity

  # column name
  billingcountry

  # column name
  billingpostalcode

  # column name
  billingstate

  # column name
  customerid

  # column name
  invoicedate

  # column name
  invoiceid

  # column name
  total
}

# input type for updating data in table "invoice"
input invoice_set_input {
  billingaddress: String
  billingcity: String
  billingcountry: String
  billingpostalcode: String
  billingstate: String
  customerid: bigint
  invoicedate: timestamptz
  invoiceid: bigint
  total: numeric
}

# aggregate stddev on columns
type invoice_stddev_fields {
  customerid: Float
  invoiceid: Float
  total: Float
}

# order by stddev() on columns of table "invoice"
input invoice_stddev_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# aggregate stddev_pop on columns
type invoice_stddev_pop_fields {
  customerid: Float
  invoiceid: Float
  total: Float
}

# order by stddev_pop() on columns of table "invoice"
input invoice_stddev_pop_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# aggregate stddev_samp on columns
type invoice_stddev_samp_fields {
  customerid: Float
  invoiceid: Float
  total: Float
}

# order by stddev_samp() on columns of table "invoice"
input invoice_stddev_samp_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# aggregate sum on columns
type invoice_sum_fields {
  customerid: bigint
  invoiceid: bigint
  total: numeric
}

# order by sum() on columns of table "invoice"
input invoice_sum_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# update columns of table "invoice"
enum invoice_update_column {
  # column name
  billingaddress

  # column name
  billingcity

  # column name
  billingcountry

  # column name
  billingpostalcode

  # column name
  billingstate

  # column name
  customerid

  # column name
  invoicedate

  # column name
  invoiceid

  # column name
  total
}

# aggregate var_pop on columns
type invoice_var_pop_fields {
  customerid: Float
  invoiceid: Float
  total: Float
}

# order by var_pop() on columns of table "invoice"
input invoice_var_pop_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# aggregate var_samp on columns
type invoice_var_samp_fields {
  customerid: Float
  invoiceid: Float
  total: Float
}

# order by var_samp() on columns of table "invoice"
input invoice_var_samp_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# aggregate variance on columns
type invoice_variance_fields {
  customerid: Float
  invoiceid: Float
  total: Float
}

# order by variance() on columns of table "invoice"
input invoice_variance_order_by {
  customerid: order_by
  invoiceid: order_by
  total: order_by
}

# columns and relationships of "invoiceline"
type invoiceline {
  # An object relationship
  invoice: invoice
  invoiceid: bigint
  invoicelineid: bigint!
  quantity: bigint

  # An object relationship
  track: track
  trackid: bigint
  unitprice: numeric
}

# aggregated selection of "invoiceline"
type invoiceline_aggregate {
  aggregate: invoiceline_aggregate_fields
  nodes: [invoiceline!]!
}

# aggregate fields of "invoiceline"
type invoiceline_aggregate_fields {
  avg: invoiceline_avg_fields
  count(columns: [invoiceline_select_column!], distinct: Boolean): Int
  max: invoiceline_max_fields
  min: invoiceline_min_fields
  stddev: invoiceline_stddev_fields
  stddev_pop: invoiceline_stddev_pop_fields
  stddev_samp: invoiceline_stddev_samp_fields
  sum: invoiceline_sum_fields
  var_pop: invoiceline_var_pop_fields
  var_samp: invoiceline_var_samp_fields
  variance: invoiceline_variance_fields
}

# order by aggregate values of table "invoiceline"
input invoiceline_aggregate_order_by {
  avg: invoiceline_avg_order_by
  count: order_by
  max: invoiceline_max_order_by
  min: invoiceline_min_order_by
  stddev: invoiceline_stddev_order_by
  stddev_pop: invoiceline_stddev_pop_order_by
  stddev_samp: invoiceline_stddev_samp_order_by
  sum: invoiceline_sum_order_by
  var_pop: invoiceline_var_pop_order_by
  var_samp: invoiceline_var_samp_order_by
  variance: invoiceline_variance_order_by
}

# input type for inserting array relation for remote table "invoiceline"
input invoiceline_arr_rel_insert_input {
  data: [invoiceline_insert_input!]!
  on_conflict: invoiceline_on_conflict
}

# aggregate avg on columns
type invoiceline_avg_fields {
  invoiceid: Float
  invoicelineid: Float
  quantity: Float
  trackid: Float
  unitprice: Float
}

# order by avg() on columns of table "invoiceline"
input invoiceline_avg_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# Boolean expression to filter rows from the table "invoiceline". All fields are combined with a logical 'AND'.
input invoiceline_bool_exp {
  _and: [invoiceline_bool_exp]
  _not: invoiceline_bool_exp
  _or: [invoiceline_bool_exp]
  invoice: invoice_bool_exp
  invoiceid: bigint_comparison_exp
  invoicelineid: bigint_comparison_exp
  quantity: bigint_comparison_exp
  track: track_bool_exp
  trackid: bigint_comparison_exp
  unitprice: numeric_comparison_exp
}

# unique or primary key constraints on table "invoiceline"
enum invoiceline_constraint {
  # unique or primary key constraint
  idx_16738_invoiceline_pkey

  # unique or primary key constraint
  idx_16738_ipk_invoiceline
}

# input type for incrementing integer column in table "invoiceline"
input invoiceline_inc_input {
  invoiceid: bigint
  invoicelineid: bigint
  quantity: bigint
  trackid: bigint
  unitprice: numeric
}

# input type for inserting data into table "invoiceline"
input invoiceline_insert_input {
  invoice: invoice_obj_rel_insert_input
  invoiceid: bigint
  invoicelineid: bigint
  quantity: bigint
  track: track_obj_rel_insert_input
  trackid: bigint
  unitprice: numeric
}

# aggregate max on columns
type invoiceline_max_fields {
  invoiceid: bigint
  invoicelineid: bigint
  quantity: bigint
  trackid: bigint
  unitprice: numeric
}

# order by max() on columns of table "invoiceline"
input invoiceline_max_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate min on columns
type invoiceline_min_fields {
  invoiceid: bigint
  invoicelineid: bigint
  quantity: bigint
  trackid: bigint
  unitprice: numeric
}

# order by min() on columns of table "invoiceline"
input invoiceline_min_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# response of any mutation on the table "invoiceline"
type invoiceline_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [invoiceline!]!
}

# input type for inserting object relation for remote table "invoiceline"
input invoiceline_obj_rel_insert_input {
  data: invoiceline_insert_input!
  on_conflict: invoiceline_on_conflict
}

# on conflict condition type for table "invoiceline"
input invoiceline_on_conflict {
  constraint: invoiceline_constraint!
  update_columns: [invoiceline_update_column!]!
  where: invoiceline_bool_exp
}

# ordering options when selecting data from "invoiceline"
input invoiceline_order_by {
  invoice: invoice_order_by
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  track: track_order_by
  trackid: order_by
  unitprice: order_by
}

# primary key columns input for table: "invoiceline"
input invoiceline_pk_columns_input {
  invoicelineid: bigint!
}

# select columns of table "invoiceline"
enum invoiceline_select_column {
  # column name
  invoiceid

  # column name
  invoicelineid

  # column name
  quantity

  # column name
  trackid

  # column name
  unitprice
}

# input type for updating data in table "invoiceline"
input invoiceline_set_input {
  invoiceid: bigint
  invoicelineid: bigint
  quantity: bigint
  trackid: bigint
  unitprice: numeric
}

# aggregate stddev on columns
type invoiceline_stddev_fields {
  invoiceid: Float
  invoicelineid: Float
  quantity: Float
  trackid: Float
  unitprice: Float
}

# order by stddev() on columns of table "invoiceline"
input invoiceline_stddev_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate stddev_pop on columns
type invoiceline_stddev_pop_fields {
  invoiceid: Float
  invoicelineid: Float
  quantity: Float
  trackid: Float
  unitprice: Float
}

# order by stddev_pop() on columns of table "invoiceline"
input invoiceline_stddev_pop_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate stddev_samp on columns
type invoiceline_stddev_samp_fields {
  invoiceid: Float
  invoicelineid: Float
  quantity: Float
  trackid: Float
  unitprice: Float
}

# order by stddev_samp() on columns of table "invoiceline"
input invoiceline_stddev_samp_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate sum on columns
type invoiceline_sum_fields {
  invoiceid: bigint
  invoicelineid: bigint
  quantity: bigint
  trackid: bigint
  unitprice: numeric
}

# order by sum() on columns of table "invoiceline"
input invoiceline_sum_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# update columns of table "invoiceline"
enum invoiceline_update_column {
  # column name
  invoiceid

  # column name
  invoicelineid

  # column name
  quantity

  # column name
  trackid

  # column name
  unitprice
}

# aggregate var_pop on columns
type invoiceline_var_pop_fields {
  invoiceid: Float
  invoicelineid: Float
  quantity: Float
  trackid: Float
  unitprice: Float
}

# order by var_pop() on columns of table "invoiceline"
input invoiceline_var_pop_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate var_samp on columns
type invoiceline_var_samp_fields {
  invoiceid: Float
  invoicelineid: Float
  quantity: Float
  trackid: Float
  unitprice: Float
}

# order by var_samp() on columns of table "invoiceline"
input invoiceline_var_samp_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate variance on columns
type invoiceline_variance_fields {
  invoiceid: Float
  invoicelineid: Float
  quantity: Float
  trackid: Float
  unitprice: Float
}

# order by variance() on columns of table "invoiceline"
input invoiceline_variance_order_by {
  invoiceid: order_by
  invoicelineid: order_by
  quantity: order_by
  trackid: order_by
  unitprice: order_by
}

# columns and relationships of "mediatype"
type mediatype {
  mediatypeid: bigint!
  name: String

  # An array relationship
  tracks(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): [track!]!

  # An aggregated array relationship
  tracks_aggregate(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): track_aggregate!
}

# aggregated selection of "mediatype"
type mediatype_aggregate {
  aggregate: mediatype_aggregate_fields
  nodes: [mediatype!]!
}

# aggregate fields of "mediatype"
type mediatype_aggregate_fields {
  avg: mediatype_avg_fields
  count(columns: [mediatype_select_column!], distinct: Boolean): Int
  max: mediatype_max_fields
  min: mediatype_min_fields
  stddev: mediatype_stddev_fields
  stddev_pop: mediatype_stddev_pop_fields
  stddev_samp: mediatype_stddev_samp_fields
  sum: mediatype_sum_fields
  var_pop: mediatype_var_pop_fields
  var_samp: mediatype_var_samp_fields
  variance: mediatype_variance_fields
}

# order by aggregate values of table "mediatype"
input mediatype_aggregate_order_by {
  avg: mediatype_avg_order_by
  count: order_by
  max: mediatype_max_order_by
  min: mediatype_min_order_by
  stddev: mediatype_stddev_order_by
  stddev_pop: mediatype_stddev_pop_order_by
  stddev_samp: mediatype_stddev_samp_order_by
  sum: mediatype_sum_order_by
  var_pop: mediatype_var_pop_order_by
  var_samp: mediatype_var_samp_order_by
  variance: mediatype_variance_order_by
}

# input type for inserting array relation for remote table "mediatype"
input mediatype_arr_rel_insert_input {
  data: [mediatype_insert_input!]!
  on_conflict: mediatype_on_conflict
}

# aggregate avg on columns
type mediatype_avg_fields {
  mediatypeid: Float
}

# order by avg() on columns of table "mediatype"
input mediatype_avg_order_by {
  mediatypeid: order_by
}

# Boolean expression to filter rows from the table "mediatype". All fields are combined with a logical 'AND'.
input mediatype_bool_exp {
  _and: [mediatype_bool_exp]
  _not: mediatype_bool_exp
  _or: [mediatype_bool_exp]
  mediatypeid: bigint_comparison_exp
  name: String_comparison_exp
  tracks: track_bool_exp
}

# unique or primary key constraints on table "mediatype"
enum mediatype_constraint {
  # unique or primary key constraint
  idx_16744_ipk_mediatype

  # unique or primary key constraint
  idx_16744_mediatype_pkey
}

# input type for incrementing integer column in table "mediatype"
input mediatype_inc_input {
  mediatypeid: bigint
}

# input type for inserting data into table "mediatype"
input mediatype_insert_input {
  mediatypeid: bigint
  name: String
  tracks: track_arr_rel_insert_input
}

# aggregate max on columns
type mediatype_max_fields {
  mediatypeid: bigint
  name: String
}

# order by max() on columns of table "mediatype"
input mediatype_max_order_by {
  mediatypeid: order_by
  name: order_by
}

# aggregate min on columns
type mediatype_min_fields {
  mediatypeid: bigint
  name: String
}

# order by min() on columns of table "mediatype"
input mediatype_min_order_by {
  mediatypeid: order_by
  name: order_by
}

# response of any mutation on the table "mediatype"
type mediatype_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [mediatype!]!
}

# input type for inserting object relation for remote table "mediatype"
input mediatype_obj_rel_insert_input {
  data: mediatype_insert_input!
  on_conflict: mediatype_on_conflict
}

# on conflict condition type for table "mediatype"
input mediatype_on_conflict {
  constraint: mediatype_constraint!
  update_columns: [mediatype_update_column!]!
  where: mediatype_bool_exp
}

# ordering options when selecting data from "mediatype"
input mediatype_order_by {
  mediatypeid: order_by
  name: order_by
  tracks_aggregate: track_aggregate_order_by
}

# primary key columns input for table: "mediatype"
input mediatype_pk_columns_input {
  mediatypeid: bigint!
}

# select columns of table "mediatype"
enum mediatype_select_column {
  # column name
  mediatypeid

  # column name
  name
}

# input type for updating data in table "mediatype"
input mediatype_set_input {
  mediatypeid: bigint
  name: String
}

# aggregate stddev on columns
type mediatype_stddev_fields {
  mediatypeid: Float
}

# order by stddev() on columns of table "mediatype"
input mediatype_stddev_order_by {
  mediatypeid: order_by
}

# aggregate stddev_pop on columns
type mediatype_stddev_pop_fields {
  mediatypeid: Float
}

# order by stddev_pop() on columns of table "mediatype"
input mediatype_stddev_pop_order_by {
  mediatypeid: order_by
}

# aggregate stddev_samp on columns
type mediatype_stddev_samp_fields {
  mediatypeid: Float
}

# order by stddev_samp() on columns of table "mediatype"
input mediatype_stddev_samp_order_by {
  mediatypeid: order_by
}

# aggregate sum on columns
type mediatype_sum_fields {
  mediatypeid: bigint
}

# order by sum() on columns of table "mediatype"
input mediatype_sum_order_by {
  mediatypeid: order_by
}

# update columns of table "mediatype"
enum mediatype_update_column {
  # column name
  mediatypeid

  # column name
  name
}

# aggregate var_pop on columns
type mediatype_var_pop_fields {
  mediatypeid: Float
}

# order by var_pop() on columns of table "mediatype"
input mediatype_var_pop_order_by {
  mediatypeid: order_by
}

# aggregate var_samp on columns
type mediatype_var_samp_fields {
  mediatypeid: Float
}

# order by var_samp() on columns of table "mediatype"
input mediatype_var_samp_order_by {
  mediatypeid: order_by
}

# aggregate variance on columns
type mediatype_variance_fields {
  mediatypeid: Float
}

# order by variance() on columns of table "mediatype"
input mediatype_variance_order_by {
  mediatypeid: order_by
}

# mutation root
type mutation_root {
  # delete data from the table: "album"
  delete_album(
    # filter the rows which have to be deleted
    where: album_bool_exp!
  ): album_mutation_response

  # delete single row from the table: "album"
  delete_album_by_pk(albumid: bigint!): album

  # delete data from the table: "artist"
  delete_artist(
    # filter the rows which have to be deleted
    where: artist_bool_exp!
  ): artist_mutation_response

  # delete single row from the table: "artist"
  delete_artist_by_pk(artistid: bigint!): artist

  # delete data from the table: "customer"
  delete_customer(
    # filter the rows which have to be deleted
    where: customer_bool_exp!
  ): customer_mutation_response

  # delete single row from the table: "customer"
  delete_customer_by_pk(customerid: bigint!): customer

  # delete data from the table: "employee"
  delete_employee(
    # filter the rows which have to be deleted
    where: employee_bool_exp!
  ): employee_mutation_response

  # delete single row from the table: "employee"
  delete_employee_by_pk(employeeid: bigint!): employee

  # delete data from the table: "genre"
  delete_genre(
    # filter the rows which have to be deleted
    where: genre_bool_exp!
  ): genre_mutation_response

  # delete single row from the table: "genre"
  delete_genre_by_pk(genreid: bigint!): genre

  # delete data from the table: "invoice"
  delete_invoice(
    # filter the rows which have to be deleted
    where: invoice_bool_exp!
  ): invoice_mutation_response

  # delete single row from the table: "invoice"
  delete_invoice_by_pk(invoiceid: bigint!): invoice

  # delete data from the table: "invoiceline"
  delete_invoiceline(
    # filter the rows which have to be deleted
    where: invoiceline_bool_exp!
  ): invoiceline_mutation_response

  # delete single row from the table: "invoiceline"
  delete_invoiceline_by_pk(invoicelineid: bigint!): invoiceline

  # delete data from the table: "mediatype"
  delete_mediatype(
    # filter the rows which have to be deleted
    where: mediatype_bool_exp!
  ): mediatype_mutation_response

  # delete single row from the table: "mediatype"
  delete_mediatype_by_pk(mediatypeid: bigint!): mediatype

  # delete data from the table: "playlist"
  delete_playlist(
    # filter the rows which have to be deleted
    where: playlist_bool_exp!
  ): playlist_mutation_response

  # delete single row from the table: "playlist"
  delete_playlist_by_pk(playlistid: bigint!): playlist

  # delete data from the table: "playlisttrack"
  delete_playlisttrack(
    # filter the rows which have to be deleted
    where: playlisttrack_bool_exp!
  ): playlisttrack_mutation_response

  # delete single row from the table: "playlisttrack"
  delete_playlisttrack_by_pk(playlistid: bigint!, trackid: bigint!): playlisttrack

  # delete data from the table: "track"
  delete_track(
    # filter the rows which have to be deleted
    where: track_bool_exp!
  ): track_mutation_response

  # delete single row from the table: "track"
  delete_track_by_pk(trackid: bigint!): track

  # insert data into the table: "album"
  insert_album(
    # the rows to be inserted
    objects: [album_insert_input!]!

    # on conflict condition
    on_conflict: album_on_conflict
  ): album_mutation_response

  # insert a single row into the table: "album"
  insert_album_one(
    # the row to be inserted
    object: album_insert_input!

    # on conflict condition
    on_conflict: album_on_conflict
  ): album

  # insert data into the table: "artist"
  insert_artist(
    # the rows to be inserted
    objects: [artist_insert_input!]!

    # on conflict condition
    on_conflict: artist_on_conflict
  ): artist_mutation_response

  # insert a single row into the table: "artist"
  insert_artist_one(
    # the row to be inserted
    object: artist_insert_input!

    # on conflict condition
    on_conflict: artist_on_conflict
  ): artist

  # insert data into the table: "customer"
  insert_customer(
    # the rows to be inserted
    objects: [customer_insert_input!]!

    # on conflict condition
    on_conflict: customer_on_conflict
  ): customer_mutation_response

  # insert a single row into the table: "customer"
  insert_customer_one(
    # the row to be inserted
    object: customer_insert_input!

    # on conflict condition
    on_conflict: customer_on_conflict
  ): customer

  # insert data into the table: "employee"
  insert_employee(
    # the rows to be inserted
    objects: [employee_insert_input!]!

    # on conflict condition
    on_conflict: employee_on_conflict
  ): employee_mutation_response

  # insert a single row into the table: "employee"
  insert_employee_one(
    # the row to be inserted
    object: employee_insert_input!

    # on conflict condition
    on_conflict: employee_on_conflict
  ): employee

  # insert data into the table: "genre"
  insert_genre(
    # the rows to be inserted
    objects: [genre_insert_input!]!

    # on conflict condition
    on_conflict: genre_on_conflict
  ): genre_mutation_response

  # insert a single row into the table: "genre"
  insert_genre_one(
    # the row to be inserted
    object: genre_insert_input!

    # on conflict condition
    on_conflict: genre_on_conflict
  ): genre

  # insert data into the table: "invoice"
  insert_invoice(
    # the rows to be inserted
    objects: [invoice_insert_input!]!

    # on conflict condition
    on_conflict: invoice_on_conflict
  ): invoice_mutation_response

  # insert a single row into the table: "invoice"
  insert_invoice_one(
    # the row to be inserted
    object: invoice_insert_input!

    # on conflict condition
    on_conflict: invoice_on_conflict
  ): invoice

  # insert data into the table: "invoiceline"
  insert_invoiceline(
    # the rows to be inserted
    objects: [invoiceline_insert_input!]!

    # on conflict condition
    on_conflict: invoiceline_on_conflict
  ): invoiceline_mutation_response

  # insert a single row into the table: "invoiceline"
  insert_invoiceline_one(
    # the row to be inserted
    object: invoiceline_insert_input!

    # on conflict condition
    on_conflict: invoiceline_on_conflict
  ): invoiceline

  # insert data into the table: "mediatype"
  insert_mediatype(
    # the rows to be inserted
    objects: [mediatype_insert_input!]!

    # on conflict condition
    on_conflict: mediatype_on_conflict
  ): mediatype_mutation_response

  # insert a single row into the table: "mediatype"
  insert_mediatype_one(
    # the row to be inserted
    object: mediatype_insert_input!

    # on conflict condition
    on_conflict: mediatype_on_conflict
  ): mediatype

  # insert data into the table: "playlist"
  insert_playlist(
    # the rows to be inserted
    objects: [playlist_insert_input!]!

    # on conflict condition
    on_conflict: playlist_on_conflict
  ): playlist_mutation_response

  # insert a single row into the table: "playlist"
  insert_playlist_one(
    # the row to be inserted
    object: playlist_insert_input!

    # on conflict condition
    on_conflict: playlist_on_conflict
  ): playlist

  # insert data into the table: "playlisttrack"
  insert_playlisttrack(
    # the rows to be inserted
    objects: [playlisttrack_insert_input!]!

    # on conflict condition
    on_conflict: playlisttrack_on_conflict
  ): playlisttrack_mutation_response

  # insert a single row into the table: "playlisttrack"
  insert_playlisttrack_one(
    # the row to be inserted
    object: playlisttrack_insert_input!

    # on conflict condition
    on_conflict: playlisttrack_on_conflict
  ): playlisttrack

  # insert data into the table: "track"
  insert_track(
    # the rows to be inserted
    objects: [track_insert_input!]!

    # on conflict condition
    on_conflict: track_on_conflict
  ): track_mutation_response

  # insert a single row into the table: "track"
  insert_track_one(
    # the row to be inserted
    object: track_insert_input!

    # on conflict condition
    on_conflict: track_on_conflict
  ): track

  # update data of the table: "album"
  update_album(
    # increments the integer columns with given value of the filtered values
    _inc: album_inc_input

    # sets the columns of the filtered rows to the given values
    _set: album_set_input

    # filter the rows which have to be updated
    where: album_bool_exp!
  ): album_mutation_response

  # update single row of the table: "album"
  update_album_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: album_inc_input

    # sets the columns of the filtered rows to the given values
    _set: album_set_input
    pk_columns: album_pk_columns_input!
  ): album

  # update data of the table: "artist"
  update_artist(
    # increments the integer columns with given value of the filtered values
    _inc: artist_inc_input

    # sets the columns of the filtered rows to the given values
    _set: artist_set_input

    # filter the rows which have to be updated
    where: artist_bool_exp!
  ): artist_mutation_response

  # update single row of the table: "artist"
  update_artist_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: artist_inc_input

    # sets the columns of the filtered rows to the given values
    _set: artist_set_input
    pk_columns: artist_pk_columns_input!
  ): artist

  # update data of the table: "customer"
  update_customer(
    # increments the integer columns with given value of the filtered values
    _inc: customer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: customer_set_input

    # filter the rows which have to be updated
    where: customer_bool_exp!
  ): customer_mutation_response

  # update single row of the table: "customer"
  update_customer_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: customer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: customer_set_input
    pk_columns: customer_pk_columns_input!
  ): customer

  # update data of the table: "employee"
  update_employee(
    # increments the integer columns with given value of the filtered values
    _inc: employee_inc_input

    # sets the columns of the filtered rows to the given values
    _set: employee_set_input

    # filter the rows which have to be updated
    where: employee_bool_exp!
  ): employee_mutation_response

  # update single row of the table: "employee"
  update_employee_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: employee_inc_input

    # sets the columns of the filtered rows to the given values
    _set: employee_set_input
    pk_columns: employee_pk_columns_input!
  ): employee

  # update data of the table: "genre"
  update_genre(
    # increments the integer columns with given value of the filtered values
    _inc: genre_inc_input

    # sets the columns of the filtered rows to the given values
    _set: genre_set_input

    # filter the rows which have to be updated
    where: genre_bool_exp!
  ): genre_mutation_response

  # update single row of the table: "genre"
  update_genre_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: genre_inc_input

    # sets the columns of the filtered rows to the given values
    _set: genre_set_input
    pk_columns: genre_pk_columns_input!
  ): genre

  # update data of the table: "invoice"
  update_invoice(
    # increments the integer columns with given value of the filtered values
    _inc: invoice_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoice_set_input

    # filter the rows which have to be updated
    where: invoice_bool_exp!
  ): invoice_mutation_response

  # update single row of the table: "invoice"
  update_invoice_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: invoice_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoice_set_input
    pk_columns: invoice_pk_columns_input!
  ): invoice

  # update data of the table: "invoiceline"
  update_invoiceline(
    # increments the integer columns with given value of the filtered values
    _inc: invoiceline_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoiceline_set_input

    # filter the rows which have to be updated
    where: invoiceline_bool_exp!
  ): invoiceline_mutation_response

  # update single row of the table: "invoiceline"
  update_invoiceline_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: invoiceline_inc_input

    # sets the columns of the filtered rows to the given values
    _set: invoiceline_set_input
    pk_columns: invoiceline_pk_columns_input!
  ): invoiceline

  # update data of the table: "mediatype"
  update_mediatype(
    # increments the integer columns with given value of the filtered values
    _inc: mediatype_inc_input

    # sets the columns of the filtered rows to the given values
    _set: mediatype_set_input

    # filter the rows which have to be updated
    where: mediatype_bool_exp!
  ): mediatype_mutation_response

  # update single row of the table: "mediatype"
  update_mediatype_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: mediatype_inc_input

    # sets the columns of the filtered rows to the given values
    _set: mediatype_set_input
    pk_columns: mediatype_pk_columns_input!
  ): mediatype

  # update data of the table: "playlist"
  update_playlist(
    # increments the integer columns with given value of the filtered values
    _inc: playlist_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlist_set_input

    # filter the rows which have to be updated
    where: playlist_bool_exp!
  ): playlist_mutation_response

  # update single row of the table: "playlist"
  update_playlist_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: playlist_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlist_set_input
    pk_columns: playlist_pk_columns_input!
  ): playlist

  # update data of the table: "playlisttrack"
  update_playlisttrack(
    # increments the integer columns with given value of the filtered values
    _inc: playlisttrack_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlisttrack_set_input

    # filter the rows which have to be updated
    where: playlisttrack_bool_exp!
  ): playlisttrack_mutation_response

  # update single row of the table: "playlisttrack"
  update_playlisttrack_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: playlisttrack_inc_input

    # sets the columns of the filtered rows to the given values
    _set: playlisttrack_set_input
    pk_columns: playlisttrack_pk_columns_input!
  ): playlisttrack

  # update data of the table: "track"
  update_track(
    # increments the integer columns with given value of the filtered values
    _inc: track_inc_input

    # sets the columns of the filtered rows to the given values
    _set: track_set_input

    # filter the rows which have to be updated
    where: track_bool_exp!
  ): track_mutation_response

  # update single row of the table: "track"
  update_track_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: track_inc_input

    # sets the columns of the filtered rows to the given values
    _set: track_set_input
    pk_columns: track_pk_columns_input!
  ): track
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# columns and relationships of "playlist"
type playlist {
  name: String
  playlistid: bigint!

  # An array relationship
  playlisttracks(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): [playlisttrack!]!

  # An aggregated array relationship
  playlisttracks_aggregate(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): playlisttrack_aggregate!
}

# aggregated selection of "playlist"
type playlist_aggregate {
  aggregate: playlist_aggregate_fields
  nodes: [playlist!]!
}

# aggregate fields of "playlist"
type playlist_aggregate_fields {
  avg: playlist_avg_fields
  count(columns: [playlist_select_column!], distinct: Boolean): Int
  max: playlist_max_fields
  min: playlist_min_fields
  stddev: playlist_stddev_fields
  stddev_pop: playlist_stddev_pop_fields
  stddev_samp: playlist_stddev_samp_fields
  sum: playlist_sum_fields
  var_pop: playlist_var_pop_fields
  var_samp: playlist_var_samp_fields
  variance: playlist_variance_fields
}

# order by aggregate values of table "playlist"
input playlist_aggregate_order_by {
  avg: playlist_avg_order_by
  count: order_by
  max: playlist_max_order_by
  min: playlist_min_order_by
  stddev: playlist_stddev_order_by
  stddev_pop: playlist_stddev_pop_order_by
  stddev_samp: playlist_stddev_samp_order_by
  sum: playlist_sum_order_by
  var_pop: playlist_var_pop_order_by
  var_samp: playlist_var_samp_order_by
  variance: playlist_variance_order_by
}

# input type for inserting array relation for remote table "playlist"
input playlist_arr_rel_insert_input {
  data: [playlist_insert_input!]!
  on_conflict: playlist_on_conflict
}

# aggregate avg on columns
type playlist_avg_fields {
  playlistid: Float
}

# order by avg() on columns of table "playlist"
input playlist_avg_order_by {
  playlistid: order_by
}

# Boolean expression to filter rows from the table "playlist". All fields are combined with a logical 'AND'.
input playlist_bool_exp {
  _and: [playlist_bool_exp]
  _not: playlist_bool_exp
  _or: [playlist_bool_exp]
  name: String_comparison_exp
  playlistid: bigint_comparison_exp
  playlisttracks: playlisttrack_bool_exp
}

# unique or primary key constraints on table "playlist"
enum playlist_constraint {
  # unique or primary key constraint
  idx_16753_ipk_playlist

  # unique or primary key constraint
  idx_16753_playlist_pkey
}

# input type for incrementing integer column in table "playlist"
input playlist_inc_input {
  playlistid: bigint
}

# input type for inserting data into table "playlist"
input playlist_insert_input {
  name: String
  playlistid: bigint
  playlisttracks: playlisttrack_arr_rel_insert_input
}

# aggregate max on columns
type playlist_max_fields {
  name: String
  playlistid: bigint
}

# order by max() on columns of table "playlist"
input playlist_max_order_by {
  name: order_by
  playlistid: order_by
}

# aggregate min on columns
type playlist_min_fields {
  name: String
  playlistid: bigint
}

# order by min() on columns of table "playlist"
input playlist_min_order_by {
  name: order_by
  playlistid: order_by
}

# response of any mutation on the table "playlist"
type playlist_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [playlist!]!
}

# input type for inserting object relation for remote table "playlist"
input playlist_obj_rel_insert_input {
  data: playlist_insert_input!
  on_conflict: playlist_on_conflict
}

# on conflict condition type for table "playlist"
input playlist_on_conflict {
  constraint: playlist_constraint!
  update_columns: [playlist_update_column!]!
  where: playlist_bool_exp
}

# ordering options when selecting data from "playlist"
input playlist_order_by {
  name: order_by
  playlistid: order_by
  playlisttracks_aggregate: playlisttrack_aggregate_order_by
}

# primary key columns input for table: "playlist"
input playlist_pk_columns_input {
  playlistid: bigint!
}

# select columns of table "playlist"
enum playlist_select_column {
  # column name
  name

  # column name
  playlistid
}

# input type for updating data in table "playlist"
input playlist_set_input {
  name: String
  playlistid: bigint
}

# aggregate stddev on columns
type playlist_stddev_fields {
  playlistid: Float
}

# order by stddev() on columns of table "playlist"
input playlist_stddev_order_by {
  playlistid: order_by
}

# aggregate stddev_pop on columns
type playlist_stddev_pop_fields {
  playlistid: Float
}

# order by stddev_pop() on columns of table "playlist"
input playlist_stddev_pop_order_by {
  playlistid: order_by
}

# aggregate stddev_samp on columns
type playlist_stddev_samp_fields {
  playlistid: Float
}

# order by stddev_samp() on columns of table "playlist"
input playlist_stddev_samp_order_by {
  playlistid: order_by
}

# aggregate sum on columns
type playlist_sum_fields {
  playlistid: bigint
}

# order by sum() on columns of table "playlist"
input playlist_sum_order_by {
  playlistid: order_by
}

# update columns of table "playlist"
enum playlist_update_column {
  # column name
  name

  # column name
  playlistid
}

# aggregate var_pop on columns
type playlist_var_pop_fields {
  playlistid: Float
}

# order by var_pop() on columns of table "playlist"
input playlist_var_pop_order_by {
  playlistid: order_by
}

# aggregate var_samp on columns
type playlist_var_samp_fields {
  playlistid: Float
}

# order by var_samp() on columns of table "playlist"
input playlist_var_samp_order_by {
  playlistid: order_by
}

# aggregate variance on columns
type playlist_variance_fields {
  playlistid: Float
}

# order by variance() on columns of table "playlist"
input playlist_variance_order_by {
  playlistid: order_by
}

# columns and relationships of "playlisttrack"
type playlisttrack {
  # An object relationship
  playlist: playlist!
  playlistid: bigint!

  # An object relationship
  track: track!
  trackid: bigint!
}

# aggregated selection of "playlisttrack"
type playlisttrack_aggregate {
  aggregate: playlisttrack_aggregate_fields
  nodes: [playlisttrack!]!
}

# aggregate fields of "playlisttrack"
type playlisttrack_aggregate_fields {
  avg: playlisttrack_avg_fields
  count(columns: [playlisttrack_select_column!], distinct: Boolean): Int
  max: playlisttrack_max_fields
  min: playlisttrack_min_fields
  stddev: playlisttrack_stddev_fields
  stddev_pop: playlisttrack_stddev_pop_fields
  stddev_samp: playlisttrack_stddev_samp_fields
  sum: playlisttrack_sum_fields
  var_pop: playlisttrack_var_pop_fields
  var_samp: playlisttrack_var_samp_fields
  variance: playlisttrack_variance_fields
}

# order by aggregate values of table "playlisttrack"
input playlisttrack_aggregate_order_by {
  avg: playlisttrack_avg_order_by
  count: order_by
  max: playlisttrack_max_order_by
  min: playlisttrack_min_order_by
  stddev: playlisttrack_stddev_order_by
  stddev_pop: playlisttrack_stddev_pop_order_by
  stddev_samp: playlisttrack_stddev_samp_order_by
  sum: playlisttrack_sum_order_by
  var_pop: playlisttrack_var_pop_order_by
  var_samp: playlisttrack_var_samp_order_by
  variance: playlisttrack_variance_order_by
}

# input type for inserting array relation for remote table "playlisttrack"
input playlisttrack_arr_rel_insert_input {
  data: [playlisttrack_insert_input!]!
  on_conflict: playlisttrack_on_conflict
}

# aggregate avg on columns
type playlisttrack_avg_fields {
  playlistid: Float
  trackid: Float
}

# order by avg() on columns of table "playlisttrack"
input playlisttrack_avg_order_by {
  playlistid: order_by
  trackid: order_by
}

# Boolean expression to filter rows from the table "playlisttrack". All fields are combined with a logical 'AND'.
input playlisttrack_bool_exp {
  _and: [playlisttrack_bool_exp]
  _not: playlisttrack_bool_exp
  _or: [playlisttrack_bool_exp]
  playlist: playlist_bool_exp
  playlistid: bigint_comparison_exp
  track: track_bool_exp
  trackid: bigint_comparison_exp
}

# unique or primary key constraints on table "playlisttrack"
enum playlisttrack_constraint {
  # unique or primary key constraint
  idx_16760_ipk_playlisttrack

  # unique or primary key constraint
  idx_16760_playlisttrack_pkey

  # unique or primary key constraint
  idx_16760_sqlite_autoindex_playlisttrack_1
}

# input type for incrementing integer column in table "playlisttrack"
input playlisttrack_inc_input {
  playlistid: bigint
  trackid: bigint
}

# input type for inserting data into table "playlisttrack"
input playlisttrack_insert_input {
  playlist: playlist_obj_rel_insert_input
  playlistid: bigint
  track: track_obj_rel_insert_input
  trackid: bigint
}

# aggregate max on columns
type playlisttrack_max_fields {
  playlistid: bigint
  trackid: bigint
}

# order by max() on columns of table "playlisttrack"
input playlisttrack_max_order_by {
  playlistid: order_by
  trackid: order_by
}

# aggregate min on columns
type playlisttrack_min_fields {
  playlistid: bigint
  trackid: bigint
}

# order by min() on columns of table "playlisttrack"
input playlisttrack_min_order_by {
  playlistid: order_by
  trackid: order_by
}

# response of any mutation on the table "playlisttrack"
type playlisttrack_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [playlisttrack!]!
}

# input type for inserting object relation for remote table "playlisttrack"
input playlisttrack_obj_rel_insert_input {
  data: playlisttrack_insert_input!
  on_conflict: playlisttrack_on_conflict
}

# on conflict condition type for table "playlisttrack"
input playlisttrack_on_conflict {
  constraint: playlisttrack_constraint!
  update_columns: [playlisttrack_update_column!]!
  where: playlisttrack_bool_exp
}

# ordering options when selecting data from "playlisttrack"
input playlisttrack_order_by {
  playlist: playlist_order_by
  playlistid: order_by
  track: track_order_by
  trackid: order_by
}

# primary key columns input for table: "playlisttrack"
input playlisttrack_pk_columns_input {
  playlistid: bigint!
  trackid: bigint!
}

# select columns of table "playlisttrack"
enum playlisttrack_select_column {
  # column name
  playlistid

  # column name
  trackid
}

# input type for updating data in table "playlisttrack"
input playlisttrack_set_input {
  playlistid: bigint
  trackid: bigint
}

# aggregate stddev on columns
type playlisttrack_stddev_fields {
  playlistid: Float
  trackid: Float
}

# order by stddev() on columns of table "playlisttrack"
input playlisttrack_stddev_order_by {
  playlistid: order_by
  trackid: order_by
}

# aggregate stddev_pop on columns
type playlisttrack_stddev_pop_fields {
  playlistid: Float
  trackid: Float
}

# order by stddev_pop() on columns of table "playlisttrack"
input playlisttrack_stddev_pop_order_by {
  playlistid: order_by
  trackid: order_by
}

# aggregate stddev_samp on columns
type playlisttrack_stddev_samp_fields {
  playlistid: Float
  trackid: Float
}

# order by stddev_samp() on columns of table "playlisttrack"
input playlisttrack_stddev_samp_order_by {
  playlistid: order_by
  trackid: order_by
}

# aggregate sum on columns
type playlisttrack_sum_fields {
  playlistid: bigint
  trackid: bigint
}

# order by sum() on columns of table "playlisttrack"
input playlisttrack_sum_order_by {
  playlistid: order_by
  trackid: order_by
}

# update columns of table "playlisttrack"
enum playlisttrack_update_column {
  # column name
  playlistid

  # column name
  trackid
}

# aggregate var_pop on columns
type playlisttrack_var_pop_fields {
  playlistid: Float
  trackid: Float
}

# order by var_pop() on columns of table "playlisttrack"
input playlisttrack_var_pop_order_by {
  playlistid: order_by
  trackid: order_by
}

# aggregate var_samp on columns
type playlisttrack_var_samp_fields {
  playlistid: Float
  trackid: Float
}

# order by var_samp() on columns of table "playlisttrack"
input playlisttrack_var_samp_order_by {
  playlistid: order_by
  trackid: order_by
}

# aggregate variance on columns
type playlisttrack_variance_fields {
  playlistid: Float
  trackid: Float
}

# order by variance() on columns of table "playlisttrack"
input playlisttrack_variance_order_by {
  playlistid: order_by
  trackid: order_by
}

# query root
type query_root {
  # fetch data from the table: "album"
  album(
    # distinct select on columns
    distinct_on: [album_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [album_order_by!]

    # filter the rows returned
    where: album_bool_exp
  ): [album!]!

  # fetch aggregated fields from the table: "album"
  album_aggregate(
    # distinct select on columns
    distinct_on: [album_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [album_order_by!]

    # filter the rows returned
    where: album_bool_exp
  ): album_aggregate!

  # fetch data from the table: "album" using primary key columns
  album_by_pk(albumid: bigint!): album

  # fetch data from the table: "artist"
  artist(
    # distinct select on columns
    distinct_on: [artist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artist_order_by!]

    # filter the rows returned
    where: artist_bool_exp
  ): [artist!]!

  # fetch aggregated fields from the table: "artist"
  artist_aggregate(
    # distinct select on columns
    distinct_on: [artist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artist_order_by!]

    # filter the rows returned
    where: artist_bool_exp
  ): artist_aggregate!

  # fetch data from the table: "artist" using primary key columns
  artist_by_pk(artistid: bigint!): artist

  # fetch data from the table: "customer"
  customer(
    # distinct select on columns
    distinct_on: [customer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customer_order_by!]

    # filter the rows returned
    where: customer_bool_exp
  ): [customer!]!

  # fetch aggregated fields from the table: "customer"
  customer_aggregate(
    # distinct select on columns
    distinct_on: [customer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customer_order_by!]

    # filter the rows returned
    where: customer_bool_exp
  ): customer_aggregate!

  # fetch data from the table: "customer" using primary key columns
  customer_by_pk(customerid: bigint!): customer

  # fetch data from the table: "employee"
  employee(
    # distinct select on columns
    distinct_on: [employee_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employee_order_by!]

    # filter the rows returned
    where: employee_bool_exp
  ): [employee!]!

  # fetch aggregated fields from the table: "employee"
  employee_aggregate(
    # distinct select on columns
    distinct_on: [employee_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employee_order_by!]

    # filter the rows returned
    where: employee_bool_exp
  ): employee_aggregate!

  # fetch data from the table: "employee" using primary key columns
  employee_by_pk(employeeid: bigint!): employee

  # fetch data from the table: "genre"
  genre(
    # distinct select on columns
    distinct_on: [genre_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genre_order_by!]

    # filter the rows returned
    where: genre_bool_exp
  ): [genre!]!

  # fetch aggregated fields from the table: "genre"
  genre_aggregate(
    # distinct select on columns
    distinct_on: [genre_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genre_order_by!]

    # filter the rows returned
    where: genre_bool_exp
  ): genre_aggregate!

  # fetch data from the table: "genre" using primary key columns
  genre_by_pk(genreid: bigint!): genre

  # fetch data from the table: "invoice"
  invoice(
    # distinct select on columns
    distinct_on: [invoice_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_order_by!]

    # filter the rows returned
    where: invoice_bool_exp
  ): [invoice!]!

  # fetch aggregated fields from the table: "invoice"
  invoice_aggregate(
    # distinct select on columns
    distinct_on: [invoice_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_order_by!]

    # filter the rows returned
    where: invoice_bool_exp
  ): invoice_aggregate!

  # fetch data from the table: "invoice" using primary key columns
  invoice_by_pk(invoiceid: bigint!): invoice

  # fetch data from the table: "invoiceline"
  invoiceline(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): [invoiceline!]!

  # fetch aggregated fields from the table: "invoiceline"
  invoiceline_aggregate(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): invoiceline_aggregate!

  # fetch data from the table: "invoiceline" using primary key columns
  invoiceline_by_pk(invoicelineid: bigint!): invoiceline

  # fetch data from the table: "mediatype"
  mediatype(
    # distinct select on columns
    distinct_on: [mediatype_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [mediatype_order_by!]

    # filter the rows returned
    where: mediatype_bool_exp
  ): [mediatype!]!

  # fetch aggregated fields from the table: "mediatype"
  mediatype_aggregate(
    # distinct select on columns
    distinct_on: [mediatype_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [mediatype_order_by!]

    # filter the rows returned
    where: mediatype_bool_exp
  ): mediatype_aggregate!

  # fetch data from the table: "mediatype" using primary key columns
  mediatype_by_pk(mediatypeid: bigint!): mediatype

  # fetch data from the table: "playlist"
  playlist(
    # distinct select on columns
    distinct_on: [playlist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_order_by!]

    # filter the rows returned
    where: playlist_bool_exp
  ): [playlist!]!

  # fetch aggregated fields from the table: "playlist"
  playlist_aggregate(
    # distinct select on columns
    distinct_on: [playlist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_order_by!]

    # filter the rows returned
    where: playlist_bool_exp
  ): playlist_aggregate!

  # fetch data from the table: "playlist" using primary key columns
  playlist_by_pk(playlistid: bigint!): playlist

  # fetch data from the table: "playlisttrack"
  playlisttrack(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): [playlisttrack!]!

  # fetch aggregated fields from the table: "playlisttrack"
  playlisttrack_aggregate(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): playlisttrack_aggregate!

  # fetch data from the table: "playlisttrack" using primary key columns
  playlisttrack_by_pk(playlistid: bigint!, trackid: bigint!): playlisttrack

  # fetch data from the table: "track"
  track(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): [track!]!

  # fetch aggregated fields from the table: "track"
  track_aggregate(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): track_aggregate!

  # fetch data from the table: "track" using primary key columns
  track_by_pk(trackid: bigint!): track
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "album"
  album(
    # distinct select on columns
    distinct_on: [album_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [album_order_by!]

    # filter the rows returned
    where: album_bool_exp
  ): [album!]!

  # fetch aggregated fields from the table: "album"
  album_aggregate(
    # distinct select on columns
    distinct_on: [album_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [album_order_by!]

    # filter the rows returned
    where: album_bool_exp
  ): album_aggregate!

  # fetch data from the table: "album" using primary key columns
  album_by_pk(albumid: bigint!): album

  # fetch data from the table: "artist"
  artist(
    # distinct select on columns
    distinct_on: [artist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artist_order_by!]

    # filter the rows returned
    where: artist_bool_exp
  ): [artist!]!

  # fetch aggregated fields from the table: "artist"
  artist_aggregate(
    # distinct select on columns
    distinct_on: [artist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [artist_order_by!]

    # filter the rows returned
    where: artist_bool_exp
  ): artist_aggregate!

  # fetch data from the table: "artist" using primary key columns
  artist_by_pk(artistid: bigint!): artist

  # fetch data from the table: "customer"
  customer(
    # distinct select on columns
    distinct_on: [customer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customer_order_by!]

    # filter the rows returned
    where: customer_bool_exp
  ): [customer!]!

  # fetch aggregated fields from the table: "customer"
  customer_aggregate(
    # distinct select on columns
    distinct_on: [customer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customer_order_by!]

    # filter the rows returned
    where: customer_bool_exp
  ): customer_aggregate!

  # fetch data from the table: "customer" using primary key columns
  customer_by_pk(customerid: bigint!): customer

  # fetch data from the table: "employee"
  employee(
    # distinct select on columns
    distinct_on: [employee_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employee_order_by!]

    # filter the rows returned
    where: employee_bool_exp
  ): [employee!]!

  # fetch aggregated fields from the table: "employee"
  employee_aggregate(
    # distinct select on columns
    distinct_on: [employee_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [employee_order_by!]

    # filter the rows returned
    where: employee_bool_exp
  ): employee_aggregate!

  # fetch data from the table: "employee" using primary key columns
  employee_by_pk(employeeid: bigint!): employee

  # fetch data from the table: "genre"
  genre(
    # distinct select on columns
    distinct_on: [genre_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genre_order_by!]

    # filter the rows returned
    where: genre_bool_exp
  ): [genre!]!

  # fetch aggregated fields from the table: "genre"
  genre_aggregate(
    # distinct select on columns
    distinct_on: [genre_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genre_order_by!]

    # filter the rows returned
    where: genre_bool_exp
  ): genre_aggregate!

  # fetch data from the table: "genre" using primary key columns
  genre_by_pk(genreid: bigint!): genre

  # fetch data from the table: "invoice"
  invoice(
    # distinct select on columns
    distinct_on: [invoice_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_order_by!]

    # filter the rows returned
    where: invoice_bool_exp
  ): [invoice!]!

  # fetch aggregated fields from the table: "invoice"
  invoice_aggregate(
    # distinct select on columns
    distinct_on: [invoice_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoice_order_by!]

    # filter the rows returned
    where: invoice_bool_exp
  ): invoice_aggregate!

  # fetch data from the table: "invoice" using primary key columns
  invoice_by_pk(invoiceid: bigint!): invoice

  # fetch data from the table: "invoiceline"
  invoiceline(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): [invoiceline!]!

  # fetch aggregated fields from the table: "invoiceline"
  invoiceline_aggregate(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): invoiceline_aggregate!

  # fetch data from the table: "invoiceline" using primary key columns
  invoiceline_by_pk(invoicelineid: bigint!): invoiceline

  # fetch data from the table: "mediatype"
  mediatype(
    # distinct select on columns
    distinct_on: [mediatype_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [mediatype_order_by!]

    # filter the rows returned
    where: mediatype_bool_exp
  ): [mediatype!]!

  # fetch aggregated fields from the table: "mediatype"
  mediatype_aggregate(
    # distinct select on columns
    distinct_on: [mediatype_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [mediatype_order_by!]

    # filter the rows returned
    where: mediatype_bool_exp
  ): mediatype_aggregate!

  # fetch data from the table: "mediatype" using primary key columns
  mediatype_by_pk(mediatypeid: bigint!): mediatype

  # fetch data from the table: "playlist"
  playlist(
    # distinct select on columns
    distinct_on: [playlist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_order_by!]

    # filter the rows returned
    where: playlist_bool_exp
  ): [playlist!]!

  # fetch aggregated fields from the table: "playlist"
  playlist_aggregate(
    # distinct select on columns
    distinct_on: [playlist_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlist_order_by!]

    # filter the rows returned
    where: playlist_bool_exp
  ): playlist_aggregate!

  # fetch data from the table: "playlist" using primary key columns
  playlist_by_pk(playlistid: bigint!): playlist

  # fetch data from the table: "playlisttrack"
  playlisttrack(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): [playlisttrack!]!

  # fetch aggregated fields from the table: "playlisttrack"
  playlisttrack_aggregate(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): playlisttrack_aggregate!

  # fetch data from the table: "playlisttrack" using primary key columns
  playlisttrack_by_pk(playlistid: bigint!, trackid: bigint!): playlisttrack

  # fetch data from the table: "track"
  track(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): [track!]!

  # fetch aggregated fields from the table: "track"
  track_aggregate(
    # distinct select on columns
    distinct_on: [track_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [track_order_by!]

    # filter the rows returned
    where: track_bool_exp
  ): track_aggregate!

  # fetch data from the table: "track" using primary key columns
  track_by_pk(trackid: bigint!): track
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "track"
type track {
  # An object relationship
  album: album
  albumid: bigint
  bytes: bigint
  composer: String

  # An object relationship
  genre: genre
  genreid: bigint

  # An array relationship
  invoicelines(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): [invoiceline!]!

  # An aggregated array relationship
  invoicelines_aggregate(
    # distinct select on columns
    distinct_on: [invoiceline_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [invoiceline_order_by!]

    # filter the rows returned
    where: invoiceline_bool_exp
  ): invoiceline_aggregate!

  # An object relationship
  mediatype: mediatype
  mediatypeid: bigint
  milliseconds: bigint
  name: String

  # An array relationship
  playlisttracks(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): [playlisttrack!]!

  # An aggregated array relationship
  playlisttracks_aggregate(
    # distinct select on columns
    distinct_on: [playlisttrack_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [playlisttrack_order_by!]

    # filter the rows returned
    where: playlisttrack_bool_exp
  ): playlisttrack_aggregate!
  trackid: bigint!
  unitprice: numeric
}

# aggregated selection of "track"
type track_aggregate {
  aggregate: track_aggregate_fields
  nodes: [track!]!
}

# aggregate fields of "track"
type track_aggregate_fields {
  avg: track_avg_fields
  count(columns: [track_select_column!], distinct: Boolean): Int
  max: track_max_fields
  min: track_min_fields
  stddev: track_stddev_fields
  stddev_pop: track_stddev_pop_fields
  stddev_samp: track_stddev_samp_fields
  sum: track_sum_fields
  var_pop: track_var_pop_fields
  var_samp: track_var_samp_fields
  variance: track_variance_fields
}

# order by aggregate values of table "track"
input track_aggregate_order_by {
  avg: track_avg_order_by
  count: order_by
  max: track_max_order_by
  min: track_min_order_by
  stddev: track_stddev_order_by
  stddev_pop: track_stddev_pop_order_by
  stddev_samp: track_stddev_samp_order_by
  sum: track_sum_order_by
  var_pop: track_var_pop_order_by
  var_samp: track_var_samp_order_by
  variance: track_variance_order_by
}

# input type for inserting array relation for remote table "track"
input track_arr_rel_insert_input {
  data: [track_insert_input!]!
  on_conflict: track_on_conflict
}

# aggregate avg on columns
type track_avg_fields {
  albumid: Float
  bytes: Float
  genreid: Float
  mediatypeid: Float
  milliseconds: Float
  trackid: Float
  unitprice: Float
}

# order by avg() on columns of table "track"
input track_avg_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

# Boolean expression to filter rows from the table "track". All fields are combined with a logical 'AND'.
input track_bool_exp {
  _and: [track_bool_exp]
  _not: track_bool_exp
  _or: [track_bool_exp]
  album: album_bool_exp
  albumid: bigint_comparison_exp
  bytes: bigint_comparison_exp
  composer: String_comparison_exp
  genre: genre_bool_exp
  genreid: bigint_comparison_exp
  invoicelines: invoiceline_bool_exp
  mediatype: mediatype_bool_exp
  mediatypeid: bigint_comparison_exp
  milliseconds: bigint_comparison_exp
  name: String_comparison_exp
  playlisttracks: playlisttrack_bool_exp
  trackid: bigint_comparison_exp
  unitprice: numeric_comparison_exp
}

# unique or primary key constraints on table "track"
enum track_constraint {
  # unique or primary key constraint
  idx_16765_ipk_track

  # unique or primary key constraint
  idx_16765_track_pkey
}

# input type for incrementing integer column in table "track"
input track_inc_input {
  albumid: bigint
  bytes: bigint
  genreid: bigint
  mediatypeid: bigint
  milliseconds: bigint
  trackid: bigint
  unitprice: numeric
}

# input type for inserting data into table "track"
input track_insert_input {
  album: album_obj_rel_insert_input
  albumid: bigint
  bytes: bigint
  composer: String
  genre: genre_obj_rel_insert_input
  genreid: bigint
  invoicelines: invoiceline_arr_rel_insert_input
  mediatype: mediatype_obj_rel_insert_input
  mediatypeid: bigint
  milliseconds: bigint
  name: String
  playlisttracks: playlisttrack_arr_rel_insert_input
  trackid: bigint
  unitprice: numeric
}

# aggregate max on columns
type track_max_fields {
  albumid: bigint
  bytes: bigint
  composer: String
  genreid: bigint
  mediatypeid: bigint
  milliseconds: bigint
  name: String
  trackid: bigint
  unitprice: numeric
}

# order by max() on columns of table "track"
input track_max_order_by {
  albumid: order_by
  bytes: order_by
  composer: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  name: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate min on columns
type track_min_fields {
  albumid: bigint
  bytes: bigint
  composer: String
  genreid: bigint
  mediatypeid: bigint
  milliseconds: bigint
  name: String
  trackid: bigint
  unitprice: numeric
}

# order by min() on columns of table "track"
input track_min_order_by {
  albumid: order_by
  bytes: order_by
  composer: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  name: order_by
  trackid: order_by
  unitprice: order_by
}

# response of any mutation on the table "track"
type track_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [track!]!
}

# input type for inserting object relation for remote table "track"
input track_obj_rel_insert_input {
  data: track_insert_input!
  on_conflict: track_on_conflict
}

# on conflict condition type for table "track"
input track_on_conflict {
  constraint: track_constraint!
  update_columns: [track_update_column!]!
  where: track_bool_exp
}

# ordering options when selecting data from "track"
input track_order_by {
  album: album_order_by
  albumid: order_by
  bytes: order_by
  composer: order_by
  genre: genre_order_by
  genreid: order_by
  invoicelines_aggregate: invoiceline_aggregate_order_by
  mediatype: mediatype_order_by
  mediatypeid: order_by
  milliseconds: order_by
  name: order_by
  playlisttracks_aggregate: playlisttrack_aggregate_order_by
  trackid: order_by
  unitprice: order_by
}

# primary key columns input for table: "track"
input track_pk_columns_input {
  trackid: bigint!
}

# select columns of table "track"
enum track_select_column {
  # column name
  albumid

  # column name
  bytes

  # column name
  composer

  # column name
  genreid

  # column name
  mediatypeid

  # column name
  milliseconds

  # column name
  name

  # column name
  trackid

  # column name
  unitprice
}

# input type for updating data in table "track"
input track_set_input {
  albumid: bigint
  bytes: bigint
  composer: String
  genreid: bigint
  mediatypeid: bigint
  milliseconds: bigint
  name: String
  trackid: bigint
  unitprice: numeric
}

# aggregate stddev on columns
type track_stddev_fields {
  albumid: Float
  bytes: Float
  genreid: Float
  mediatypeid: Float
  milliseconds: Float
  trackid: Float
  unitprice: Float
}

# order by stddev() on columns of table "track"
input track_stddev_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate stddev_pop on columns
type track_stddev_pop_fields {
  albumid: Float
  bytes: Float
  genreid: Float
  mediatypeid: Float
  milliseconds: Float
  trackid: Float
  unitprice: Float
}

# order by stddev_pop() on columns of table "track"
input track_stddev_pop_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate stddev_samp on columns
type track_stddev_samp_fields {
  albumid: Float
  bytes: Float
  genreid: Float
  mediatypeid: Float
  milliseconds: Float
  trackid: Float
  unitprice: Float
}

# order by stddev_samp() on columns of table "track"
input track_stddev_samp_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate sum on columns
type track_sum_fields {
  albumid: bigint
  bytes: bigint
  genreid: bigint
  mediatypeid: bigint
  milliseconds: bigint
  trackid: bigint
  unitprice: numeric
}

# order by sum() on columns of table "track"
input track_sum_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

# update columns of table "track"
enum track_update_column {
  # column name
  albumid

  # column name
  bytes

  # column name
  composer

  # column name
  genreid

  # column name
  mediatypeid

  # column name
  milliseconds

  # column name
  name

  # column name
  trackid

  # column name
  unitprice
}

# aggregate var_pop on columns
type track_var_pop_fields {
  albumid: Float
  bytes: Float
  genreid: Float
  mediatypeid: Float
  milliseconds: Float
  trackid: Float
  unitprice: Float
}

# order by var_pop() on columns of table "track"
input track_var_pop_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate var_samp on columns
type track_var_samp_fields {
  albumid: Float
  bytes: Float
  genreid: Float
  mediatypeid: Float
  milliseconds: Float
  trackid: Float
  unitprice: Float
}

# order by var_samp() on columns of table "track"
input track_var_samp_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

# aggregate variance on columns
type track_variance_fields {
  albumid: Float
  bytes: Float
  genreid: Float
  mediatypeid: Float
  milliseconds: Float
  trackid: Float
  unitprice: Float
}

# order by variance() on columns of table "track"
input track_variance_order_by {
  albumid: order_by
  bytes: order_by
  genreid: order_by
  mediatypeid: order_by
  milliseconds: order_by
  trackid: order_by
  unitprice: order_by
}

